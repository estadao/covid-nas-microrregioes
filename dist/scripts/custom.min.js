/*
///////////////////////////
// Load the smaller file //
// with the search data  //
///////////////////////////
 (\__/)  ||
 (•ㅅ•)  ||
 ( 　 づ || */

d3.json("data/processed/search-keys.json").then(function(searchKeys){

	/*
	////////////////////////////
	// Load the big file     //
	// with the chart data  //
	/////////////////////////
	 (\__/)  ||
	 (•ㅅ•)  ||
	 ( 　 づ || */

	d3.csv("data/processed/microregions.csv").then(function(datapoints) {

		/*
		/////////////////////////////
		// Fix the last update box //
		/////////////////////////////
		 (\__/)  ||
		 (•ㅅ•)  ||
		 ( 　 づ || */	


		// Ugly string slicing (god, I miss Python's string[0:4])
		let lastUpdate = datapoints[datapoints.length - 1].date; // YYYY-MM-DD
		lastUpdate = lastUpdate[8] + lastUpdate[9] + "." + // Day
		 	lastUpdate[5] + lastUpdate[6] + "." + // Month
			lastUpdate[0] + lastUpdate[1] + lastUpdate[2] + lastUpdate[3]; // Year

		document.querySelector(".last_update").textContent = `Dados atualizados em ${lastUpdate}`;

		/*
		/////////////////////
		// Define colors   //
		////////////////////
		 (\__/)  ||
		 (•ㅅ•)  ||
		 ( 　 づ || */	

		 let highlightColor = "#ff3333"; // Light red
		 let hoverColor = "#808080" // Dark gray
		 let secondaryColor = "#f0f0f0"; // Light gray


		/*
		/////////////////////
		// Parse the data //
		////////////////////
		 (\__/)  ||
		 (•ㅅ•)  ||
		 ( 　 づ || */	

		// Keep only city data with at least n cases
		let minCases = 1;
		datapoints = datapoints.filter(d => ( (+d.last_available_confirmed >= minCases) & 
			(+d.new_deaths_rolling >= 0) &
			(+d.new_confirmed_rolling >= 0)
		));

	    // Group by microrregion
	    let nested = d3.nest()
	    	.key(d => d.cod_micro)
	    	.entries(datapoints);

		/*
		/////////////////////
		// Draw the chart  //
		////////////////////
		 (\__/)  ||
		 (•ㅅ•)  ||
		 ( 　 づ || */

	    function draw(measure, isResize) {

			// Sets the first viz to be São Paulo, total cases
			let regionId = "3515061";
			let hoverId = null;
			let regionName = "Microrregião de São Paulo";

			/*
			///////////////////////////////////
			// Check if this a mobile device //
			///////////////////////////////////
			 (\__/)  ||
			 (•ㅅ•)  ||
			 ( 　 づ || */

		    function isMobile() {
			  if(window.innerWidth <= 800) {

			     return true;

			  } // End of if

			  else {

			     return false;

			  } // End of else

			} // End of isMobile()

			/*
			////////////////////////////////
			// Set dimensions accordingly //
			////////////////////////////////
			 (\__/)  ||
			 (•ㅅ•)  ||
			 ( 　 づ || */


			if (isMobile()) {

				var baseWidth =  window.innerWidth * .95;

				var margin = { top: 10, left: 42, right: 88, bottom: 20},
				    height = 500 - margin.top - margin.bottom,
				    width = baseWidth - margin.left - margin.right;

			}

			else {

				var baseWidth =  window.innerWidth * 0.90 > 1000 ? 1000 : window.innerWidth * 0.90;

				var margin = { top: 10, left: 50, right: 50, bottom: 60},
				    height = 500 - margin.top - margin.bottom,
				    width = baseWidth - margin.left - margin.right;

			}

			/*
			///////////////////////////////
			// Set scales and generators //
			///////////////////////////////
			 (\__/)  ||
			 (•ㅅ•)  ||
			 ( 　 づ || */

			// Days passed since the first day avaliable in the data to today	
			let maxDays = Math.round((Date.now() - new Date("2020-02-26").getTime()) / (1000 * 3600 * 24) + 1);
			let maxCases = 15000;
			// let maxDeaths = 1000;

			// Uncoment the lines below to make the yAxis change automatically
			//maxCases = d3.max(datapoints.map(d => +d[measure]));

			if (measure == "last_available_confirmed") {

				var boundaries = { 
						"xAxis": [0, maxDays + 10],
						"yAxis": [minCases, maxCases] 
					}
			}

			else if (measure == "new_confirmed_rolling") {

				var boundaries = { 
					"xAxis" : [0, maxDays + 10],
					"yAxis" : [0, 1000] 
				}

			}

			else if (measure == "last_available_deaths") {

				var boundaries = { 
					"xAxis": [0, maxDays + 10],
					"yAxis": [0, maxCases] 
				}

			}

			else if (measure == "new_deaths_rolling") {
				
				var boundaries = { 
					"xAxis" : [0, maxDays + 10],
					"yAxis" : [0, 1000] 
				}

			}


			let xPositionScale = d3.scaleLinear()
				.domain(boundaries.xAxis) 
				.range([0, width]);

			let yPositionScale = d3.scaleSymlog()
				.domain(boundaries.yAxis)
				.range([height, 0]);


		    let lineGenerator = d3.line()
		        .x(d => xPositionScale(+d.days_since_outbreak))
		        .y(d =>yPositionScale(+d[measure]))
		        // .curve(d3.curveBasis);


			/*
			///////////////////////////
			// Add the actual chart //
			/////////////////////////
			 (\__/)  ||
			 (•ㅅ•)  ||
			 ( 　 づ || */

			// Add the svg
			let svg = d3.select(`#chart_holder_${measure}`)
				.append("svg")
				.attr("class", "svg_chart")
				.attr("id", `svg_${measure}`)
				.attr("height", height + margin.top + margin.bottom)
			    .attr("width", width + margin.left + margin.right)
			    .style("background", "#fff")
			    .append("g")
			    .attr("transform", `translate(${margin.left},${margin.top})`)


			// Add the x axis


			// Dynamically generate a tick for every 10 days
			let tickValues = [ 1 ];
			let maxTick = Math.floor((maxDays + 10) / 10) * 10;

			let tick = 10;
			do {

				tickValues.push(tick);
				tick += 10;

			} while (tick <= maxTick)

			let xAxis = d3.axisBottom(xPositionScale)
			      .tickValues(tickValues)
			      .tickFormat(d => d == 1 ? d + 'º dia' : d + 'º');

			let xAxisHolder = svg.append("g")
			     .attr("class", "x_axis")
			     .attr("fill", "black")
			     .attr("transform", `translate(0,${height})`)
			     .call(xAxis);

			xAxisHolder.select(".domain") // Selects the axis vertical line...
			        .remove()       // ...and removes it

			xAxisHolder.selectAll(".x-axis .tick text")
			  .attr("class", "ordinary_tick");

			// Add the yAxis
			let yAxisTicks = [1, 10, 100, 1000, 10000];

			let yAxis = d3.axisLeft(yPositionScale)
			    .tickValues(yAxisTicks)
			    .tickSize(0 - width) // Make the ticks occupy the whole svg, left to right
			    .tickFormat(d => d >= 1000 ? d / 1000 + " mil" : d);

			let yAxisHolder = svg.append("g")
			     .attr("class", "y_axis")
			     .attr("fill", "black")
			     .attr("transform", "translate(-1,0)")
			     .call(yAxis);

			yAxisHolder.select(".domain") // Selects the axis vertical line...
			        .remove()       // ...and removes it

			// Adds an explainer to the yAxis
			var label = "casos";


			let yTicks = yAxisHolder.selectAll(".tick")
				.each(function(d){

					if (d == 10000) {

			    		let element = d3.select(this);
			    		let elementLabel = element.select("text");

			    		element.append("text")
			    			.text(label)
			    			.attr("x", elementLabel.attr("x"))
			    			.attr("dy", 15)
			    			.attr("fill", "currentColor")
			    			.attr("class", "tick_label");

			    	return;

					}

			})

			// Customize tick styles
			svg.selectAll(".tick line")
					.attr("stroke", "#777") // Styling the ticks - color
					.attr("stroke-dasharray", "2,3"); // Styling the ticks - dot size

			// Instead of using svg labels, use d3 tip
			function addLabels() {

				// Removes all labels so we can simply add the right ones later
				svg.selectAll(".label_holder")
					.remove();

				// Adds informative text for the regionId and hoverId
				let labelHolders = svg.selectAll(".labels")
					.data(nested.filter(d => (d.key == regionId) | (d.key == hoverId)))
					.enter()
					.append("g")
					.attr("class", "label_holder")
					.attr("id", d => `label_${d.key}`);

				labelHolders.append("text")
					.attr("class", "line_label_day_count")
					.text(d => `${+d.values[d.values.length - 1].days_since_outbreak}º dia após 1º caso`)
					.attr("x", d => xPositionScale(+d.values[d.values.length - 1].days_since_outbreak))
					.attr("y", d => yPositionScale(+d.values[d.values.length - 1][measure]))
					.attr("dx", 2)
					.attr("dy", -30)


				labelHolders.append("text")
					.attr("class", "line_label_title")
					.attr("x", d => xPositionScale(+d.values[d.values.length - 1].days_since_outbreak))
					.attr("y", d => yPositionScale(+d.values[d.values.length - 1][measure]))
					.text(d => `${d.values[0].nome_micro} (${d.values[0].state})`)
					.attr("dx", 2)
					.attr("dy", -15);


				labelHolders.append("text")
					.attr("class", "line_label_content")
					.attr("x", d => xPositionScale(+d.values[d.values.length - 1].days_since_outbreak))
					.attr("y", d => yPositionScale(+d.values[d.values.length - 1][measure]))
					.text(function(d) {

						let unit = ["last_available_confirmed", "new_confirmed_rolling"].includes(measure) ? "casos" : "mortes"

						if (["last_available_confirmed", "last_available_deaths"].includes(measure)) {
							return ` ${+d.values[d.values.length - 1][measure]} ${unit} no total`
						}
						else {
							return `Média de ${Math.floor(+d.values[d.values.length - 1][measure])} ${unit}`;
						}
					})
					.attr("dx", 2)
					.attr("dy", 0);

				labelHolders.append("text")
					.text(function(d){

						if (["last_available_confirmed", "last_available_deaths"].includes(measure)) {
							return "";
						}

						else {
							return "nos últimos 5 dias";
						}

					})
					.attr("class", "line_label_content")
					.attr("x", d => xPositionScale(+d.values[d.values.length - 1].days_since_outbreak))
					.attr("y", d => yPositionScale(+d.values[d.values.length - 1][measure]))
					.attr("dx", 2)
					.attr("dy", 15);

			}

			addLabels();
			
			// Adds the visible lines
			svg.selectAll("lines")
				.data(nested)
				.enter()
				.append("path")
				.attr("class", d => d.key == regionId ? "selected_line" : "secondary_line")
				.attr("id", d => `line_${d.key}`)
				.style("stroke", d => d.key == regionId ? highlightColor : secondaryColor)
				// .style("stroke-width", 2)
				.style("opacity", .7)
				.style("fill", "none")
				// .style("pointer-events", "none")
				.attr("d", d => lineGenerator(d.values))
			    .on("mouseover", function(d){

			    	if (!isMobile()) {

			    		// Get the id for highlight
			    		hoverId = d.key;

			    		// Hide the other line
			    		svg.select(".selected_line")
			    			.style("stroke", secondaryColor);

			    		// Highlight this line
			    		d3.select(this)
			    			.style("stroke", d => d.key == regionId ? highlightColor : hoverColor)
			    			.raise();

			    		// Delete all tooltips not related to this line or the selected one
			    		// and create a tooltop for this line
			    		addLabels()

			    		// Hide the selected one tooltip
			    		svg.select(`#label_${regionId}`)
			    			.style("visibility", "hidden");

			    	}


			    })
			    .on("mouseout", function(d){

			    	if (!isMobile()) {

			    		console.log("mouseout")


			    		// Make sure there is no hoverId, so the
			    		// next call to addLabels() will add the correct ones
			    		hoverId = null;

			    		// Remove this label
			    		addLabels();

			    		// Unhighlight this line
			    		d3.select(this)
			    			.style("stroke", d => d.key == regionId ? highlightColor : secondaryColor);

			    		// Raise tand highlight again the selected line
			    		svg.select(".selected_line")
			    			.style("stroke", highlightColor)
			    			.raise();

			    		// Show the selected one tooltip
			    		svg.select(`#label_${regionId}`)
			    			.style("visibility", "visible");


			    	}
			    	

			    })
			    .on("click", function(d){

			    	// 1. Select this line parameters
			    	regionName = d.values[0].nome_micro;
			    	regionId = d.key;
			    	hoverId = null;

			    	// 2. Unhighlight any other lines
			    	svg.select(".selected_line")
			    		.attr("class", "secondary_line")
			    		.style("stroke", d => d.key == regionId ? highlightColor : secondaryColor);

			    	// 3. Highlight this line
		    		d3.select(this)
		    			.attr("class", "selected_line")
		    			.style("stroke", d => d.key == regionId ? highlightColor : hoverColor)
		    			.raise();

			    	// 4. Remove all the tooltips that are not from this line
			    	addLabels();

			    	// Fill input
			    	document.querySelector(`#autoComplete_${measure}`).value = `Microrregião: ${regionName}`

				});

			// Defines an autcomplete search
			function startAutocomplete() {

				if (!isResize) {

					new autoComplete({
					    data: {
					        src: searchKeys,
					        key: ["citiesWithinUnidecoded"],
					    	cache: true,
					    },
					    trigger: {
					    	event: ["input"]
					    },
					    placeHolder: "Digite uma cidade...",     // Place Holder text                 | (Optional)
					    selector: `#autoComplete_${measure}`,           // Input field selector              | (Optional)
					    threshold: 1,                        // Min. Chars length to start Engine | (Optional)
					    debounce: 300,                       // Post duration for engine to start | (Optional)
					    searchEngine: "strict",              // Search Engine type/mode           | (Optional)
					    resultsList: {                       // Rendered results list object      | (Optional)
					        render: true,
					        container: source => {
					            source.setAttribute("id", `region_list_${measure}`);
					            source.setAttribute("class", "region_list");
					        },
					        destination: document.querySelector(`#autoComplete${measure}`),
					        position: "afterend",
					        element: "div"
					    },
					    maxResults: 5,                         // Max. number of rendered results | (Optional)
					    highlight: true,                       // Highlight matching results      | (Optional)
					    resultItem: {                          // Rendered result item            | (Optional)
					        content: (data, source) => {
					        	let content = `<div class='list_item'><span class="region_name">Microrregião: ${data.value.regionName}</span><br><span class="cities_within">Cidades: ${data.value.citiesWithin}</span></div>`
					            source.innerHTML = content;
					        },
					        element: "ul"
					    },
					    noResults: () => {                     // Action script on noResults      | (Optional)
					        const result = document.createElement("li");
					        result.setAttribute("class", "no_result");
					        result.setAttribute("tabindex", "1");
					        result.innerHTML = "Cidade não encontrada";
					        document.querySelector(`#region_list_${measure}`).appendChild(result);
					    },
					    onSelection: feedback => {             // Action script onSelection event | (Optional)

					    	regionId = feedback.selection.value.regionId;

					    	let svg = d3.select(`#svg_${measure}`)

					    	// Hide the previously selected line
					    	svg.select('.selected_line')
					    		.attr("class", "secondary_line")
					    		.style("stroke", secondaryColor);

					    	// Select a new line and highlight it
					    	svg.select(`#line_${regionId}`)
					    		.attr("class", "selected_line")
					    		.style("stroke", highlightColor)
					    		.raise();

					    	// Handle labels
					    	addLabels();

					    	// Fill input
					    	document.querySelector(`#autoComplete_${measure}`).value = `Microrregião: ${feedback.selection.value.regionName}`

					    }

					});

				}

			}

			startAutocomplete();

			// Raises the selected line
			svg.select(".selected_line")
				.raise();


	    } // End of draw

	    let measures = ["last_available_confirmed", "new_confirmed_rolling", "last_available_deaths", "new_deaths_rolling" ];
	    for (let measure of measures) {

			// Draw chart
			draw(measure);  

	    }

		/*
		//////////////////////////
		// Make it interactive //
		////////////////////////
		 (\__/)  ||
		 (•ㅅ•)  ||
		 ( 　 づ || */

		// Redraw on resize
		function resize() {

			function isMobile() {
			  if(window.innerWidth <= 800) {

			     return true;

			  } // End of if

			  else {

			     return false;

			  } // End of else

			} // End of isMobile()

			// Only resize if not on nobile
			if (!isMobile()) {

				d3.selectAll(".svg_chart").remove();

				// Remove all autocomplete 
			    for (let measure of measures) {

			    	draw(measure, true);

				}


			}

		}

		window.addEventListener('resize', resize);

		// On search, change the highlight bar and respective labels

		// Reset input on click

		let searchBars = document.querySelectorAll(".autoComplete");

		function clearSearchBars() {

			for (let searchBar of searchBars) {

				searchBar.value = "";

			}

		}

		for (let searchBar of searchBars) {

			searchBar.addEventListener("click", function() {

				clearSearchBars();

			})

		}
		
		// On load, clear search bar cache (required for Firefox)
		clearSearchBars();

	})

})
